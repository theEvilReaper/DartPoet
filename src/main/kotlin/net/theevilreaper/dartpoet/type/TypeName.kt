package net.theevilreaper.dartpoet.type

import net.theevilreaper.dartpoet.code.CodeWriter
import net.theevilreaper.dartpoet.code.buildCodeString
import net.theevilreaper.dartpoet.util.NULLABLE_CHAR
import java.lang.reflect.Type
import kotlin.reflect.KClass

/**
 * Represents a sealed class hierarchy for custom type names.
 *
 * The [TypeName] class hierarchy is designed to handle custom type names, including their nullability information.
 * It serves as a base class for various custom type implementations and provides the framework for emitting string
 * representations, creating copies with different nullability, and comparing instances based on their cached string
 * representations.
 *
 * @param isNullable a flag indicating whether the custom type can be null (default is false)
 * @author theEvilReaper
 * @since 1.0.0
 */
sealed class TypeName(val isNullable: Boolean) {

    /**
     * Lazily computes and caches a string representation of this [TypeName] instance.
     *
     * This method generates a string representation of the [TypeName], taking into account whether it is nullable or not,
     * and caches the result. Subsequent calls to [toString] return the cached value, avoiding unnecessary computation.
     *
     * @return the string representation of this [TypeName] instance
     */
    private val cachedString: String by lazy {
        buildCodeString {
            emit(this)
            if (isNullable) emit(NULLABLE_CHAR)
        }
    }

    /**
     * Returns the cached string representation of this [TypeName] instance.
     *
     * This method retrieves the cached string representation of the [TypeName] generated by [cachedString].
     * It ensures efficient reuse of the previously computed string value.
     *
     * @return the cached string representation of this [TypeName] instance
     */
    override fun toString(): String = cachedString

    /**
     * Emits a string representation of this [TypeName] to the specified [CodeWriter].
     *
     * This method is responsible for emitting the string representation of the [TypeName] to a [CodeWriter] instance.
     * Subclasses must override this method to provide their specific implementation for generating the string
     * representation.
     *
     * @param out the [CodeWriter] instance to which the string representation is emitted
     * @return the same [CodeWriter] instance for method chaining
     */
    internal abstract fun emit(out: CodeWriter): CodeWriter

    /**
     * Creates a copy of this [TypeName] with an optional nullable flag.
     *
     * This method generates a new instance of a [TypeName] based on the current instance, optionally allowing the
     * nullable flag to be updated. Subclasses should implement this method to return a new instance with the provided
     * nullable flag.
     *
     * @param nullable a flag indicating whether the copied [TypeName] should be nullable (default is the current value)
     * @return a new [TypeName] instance with the specified nullable flag
     */
    internal abstract fun copy(nullable: Boolean = this.isNullable): TypeName

    /**
     * Checks if this [TypeName] is equal to another object.
     *
     * This method compares this [TypeName] instance with another object and returns `true` if they are equal.
     * Equality is determined by comparing the cached string representations of the two [TypeName] instances.
     *
     * @param other the object to compare with this [TypeName]
     * @return `true` if this [TypeName] is equal to the provided object, `false` otherwise
     */
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as TypeName

        return cachedString == other.cachedString
    }

    /**
     * Computes the hash code of this [TypeName].
     *
     * This method generates a hash code for this [TypeName] based on its cached string representation
     *
     * @return the hash code of this [TypeName]
     */
    override fun hashCode(): Int = cachedString.hashCode()

    companion object {

        /**
         * Converts a [Type] from the jdk into a corresponding Dart type represented by a [TypeName].
         *
         * This method is used to map Java types to Dart types. It handles primitive types, arrays, and other custom types.
         *
         * @param type the Java type to be converted
         * @return the Dart type represented as a [TypeName]
         * @throws IllegalArgumentException if the provided [Type] is not a supported type or if an array type is encountered
         *                                 (arrays are not supported at the moment)
         */
        @Throws(IllegalArgumentException::class)
        internal fun get(type: Type): TypeName {
            return when (type) {
                is Class<*> -> when {
                    type === Boolean::class.javaPrimitiveType -> BOOLEAN
                    type === Int::class.javaPrimitiveType -> INTEGER
                    type === Long::class.javaPrimitiveType -> INTEGER
                    type === Double::class.javaPrimitiveType -> DOUBLE
                    type === Float::class.javaPrimitiveType -> DOUBLE
                    type === String::class.javaPrimitiveType -> STRING
                    type.isArray -> throw IllegalArgumentException("An array type is not supported at the moment")
                    else -> type.asClassName()
                }

                else -> throw IllegalArgumentException("Received unexpected type $type")
            }
        }

        /**
         * Parses a [KClass] representing a primitive data type in Dart to a matching [ClassName] constant.
         *
         * This method is used to map Kotlin primitive types to corresponding [ClassName] constants, which are used
         * to represent Dart primitive data types.
         *
         * @param type the [KClass] to be mapped to a [ClassName]
         * @return the mapped [ClassName] constant
         * @throws IllegalArgumentException if the given [KClass] is not a supported primitive class
         */
        @Throws(IllegalArgumentException::class)
        internal fun parseSimpleKClass(type: KClass<*>): ClassName {
            return when (type) {
                Boolean::class -> BOOLEAN
                Int::class -> INTEGER
                Long::class -> INTEGER
                Double::class -> DOUBLE
                Float::class -> DOUBLE
                String::class -> STRING
                else -> throw IllegalArgumentException("The given $type is not a primitive object")
            }
        }
    }
}

@JvmField
val BOOLEAN: ClassName = ClassName("bool")

@JvmField
val INTEGER: ClassName = ClassName("int")

@JvmField
val DOUBLE: ClassName = ClassName("double")

@JvmField
val STRING: ClassName = ClassName("String")

@JvmField
val CONST: ClassName = ConstClassName()

@JvmField
val DYNAMIC: ClassName = DynamicClassName()

@JvmName("get")
fun KClass<*>.asTypeName(): TypeName = asClassName()

/** Returns a [TypeName] equivalent to this [Type].  */
@JvmName("get")
fun Type.asTypeName(): TypeName = TypeName.get(this)
